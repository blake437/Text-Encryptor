<html>
  <head>
    <style>
      /* Add basic styles for tabs */
      .tab {
        display: flex;
        cursor: pointer;
        padding: 10px;
        background-color: #f1f1f1;
        border: 1px solid #ccc;
        margin-right: 5px;
      }

      .tab:hover {
        background-color: #ddd;
      }

      .tab-content {
        display: none;
        border: 1px solid #ccc;
        padding: 15px;
        margin-top: 10px;
      }

      .tab-content.active {
        display: block !important;
      }
    </style>
  </head>
  <body>
    <input type="text" placeholder="encryption key" id="key">
    <input type="number" placeholder="message number" id="num">

    <!-- Tabs -->
    <div id="tabs">
      <div class="tab" onclick="showTabContent('tab1')">Encrypt</div>
      <div class="tab" onclick="showTabContent('tab2')">Decrypt</div>
    </div>
    <div id="tab1" class="tab-content active">
      Plaintext:
      <textarea id="plaintext"></textarea>
      <button type="button" onclick="encrypt()">Encrypt</button>
    </div>
    <div id="tab2" class="tab-content">
      Ciphertext:
      <textarea id="ciphertext"></textarea>
      <button type="button" onclick="decrypt()">Decrypt</button>
    </div>
  </body>
  <script>
    // JavaScript to handle tab switching
    function showTabContent(tabId) {
      // Hide all tab content
      const contents = document.querySelectorAll('.tab-content');
      contents.forEach(content => content.classList.remove('active'));

      // Show the selected tab content
      const selectedTab = document.getElementById(tabId);
      selectedTab.classList.add('active');
    }

     // Convert a string to BigInt using fixed-width (5 digits) encoding
  function stringToBigInt(str) {
    // Pad each char code to 5 digits to ensure unambiguous decoding
    let charCodes = Array.from(str).map(char => char.charCodeAt(0).toString().padStart(5, '0')).join('');
    return BigInt(charCodes);
  }

  // Convert a BigInt back to a string, decoding in fixed-width (5 digits)
  function bigIntToString(bigInt) {
    let strRepresentation = bigInt.toString();
    // Pad left if string length is not a multiple of 5
    if (strRepresentation.length % 5 !== 0) {
      strRepresentation = strRepresentation.padStart(Math.ceil(strRepresentation.length / 5) * 5, '0');
    }
    const charCodes = [];
    for (let i = 0; i < strRepresentation.length; i += 5) {
      let code = parseInt(strRepresentation.slice(i, i+5), 10);
      charCodes.push(code);
    }
    return charCodes.map(code => String.fromCharCode(code)).join('');
  }

    // Helper function to compute SHA-256 hash
    async function sha256(message) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Function to handle Encrypt button click
    async function encrypt() { 
      const key = document.getElementById('key').value; // Get the encryption key
      let num = document.getElementById('num').value; // Get the message number
      const plaintext = document.getElementById('plaintext').value; // Get the plaintext

      // Validate inputs
      if (!key || !plaintext) {
        alert("Please provide both an encryption key and plaintext.");
        return;
      }

      // Set the message number to a random number if it is 0 or not set
      if (!num || num === "0") {
        num = Math.floor(Math.random() * 1000000); // Generate a random number (e.g., between 0 and 999999)
        document.getElementById('num').value = num; // Update the input field with the random number
      }

      const bigintplaintext = stringToBigInt(plaintext);

      // Compute hashes
      const keyHash = await sha256(key);
      const numHash = await sha256(num);

      // Convert hexadecimal hash values to BigInt for multiplication
      const keyBigInt = BigInt('0x' + keyHash);
      const numBigInt = BigInt('0x' + numHash);

      // Multiply the two hashes
      const multipliedHashBigInt = keyBigInt * numBigInt;

      // Take the hash of the result
      const finalHash = await sha256(multipliedHashBigInt.toString());

      console.log('Final Hash:', finalHash);

      // `finalHash` is for encryption logic
      const bigintciphertext = bigintplaintext * BigInt('0x' + finalHash);

      const ciphertext = bigIntToString(bigintciphertext);

      document.getElementById('ciphertext').value = ciphertext;

      showTabContent('tab2');
    }

    // Function to handle Decrypt button click
    async function decrypt() {
      const key = document.getElementById('key').value; // Get the encryption key
      const num = document.getElementById('num').value; // Get the message number
      const ciphertext = document.getElementById('ciphertext').value; // Get the ciphertext

      // Validate inputs
      if (!key || !ciphertext) {
        alert("Please provide both an encryption key and ciphertext.");
        return;
      }

      // Compute hashes
      const keyHash = await sha256(key);
      const numHash = await sha256(num);

      // Convert hexadecimal hash values to BigInt for multiplication
      const keyBigInt = BigInt('0x' + keyHash);
      const numBigInt = BigInt('0x' + numHash);

      // Multiply the two hashes
      const multipliedHashBigInt = keyBigInt * numBigInt;

      // Take the hash of the result
      const finalHash = await sha256(multipliedHashBigInt.toString());

      console.log('Final Hash for Decryption:', finalHash);

      // `finalHash` is for decryption logic
      const bigintciphertext = stringToBigInt(ciphertext);

      const bigintplaintext = bigintciphertext / BigInt('0x' + finalHash);

      const plaintext = bigIntToString(bigintplaintext);

      document.getElementById('plaintext').value = plaintext;

      showTabContent('tab1');
    }
  </script>
</html>
î€€
